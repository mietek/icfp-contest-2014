LDC 0          ; initial state
LDC 0
CONS
LDF @stepFunction
CONS
RTN

LD 0 1         ; load world state ; @stepFunction
CDR            ; lambda-man status
CAR
CDR            ; and his position
CAR

LD 0 1         ; load world state
CDR            ; l-man again
CAR
CDR            ; extract direction
CDR
CAR

LD 0 1
CDR            ; extract l-man again
CAR
CDR            ; as well as his position
CAR
LD 0 0         ; compare with previous position
LDF @comparePairs
AP 2

LD 0 1         ; extract current world map
CAR

LD 0 1         ; load some entropy from the world
CDR            ; extract ghosts
CDR
CAR
CAR            ; take first from the list
CDR            ; then his coords
CAR
CAR            ; and get the value of x

LDF @chooseNewDirection
AP 5
CONS           ; return (curr_pos, new_dir)
RTN


LD 0 1         ; current direction ; @chooseNewDirection
LD 0 2         ; is it stuck?
TSEL @changeDirection @continue
LD 0 4         ; pseudo-RNG seed ; @changeDirection
LDC 3          ; 1/3 chance it will go counter-clockwise
LDF @modulo
AP 2
LDF @rotate
AP 2

LD 0 0         ; but maybe it's better to follow dots ; @continue
LD 0 3
LDF @followDots
AP 1
RTN

LD 0 0         ; previous direction ; @rotate
LD 0 1         ; rotation type
TSEL @counterClockWise @clockWise
LDC 2          ; @counterClockWise
ADD
LDC 1          ; @clockWise
ADD
LDC 4
LDF @modulo
AP 2
RTN

LD 0 2         ; the map ; @followDots
LD 0 1         ; l-man position
LDC 0          ; check to the right
LDC 1
CONS
LDF @addVectors
AP 2
LDF @isThereFood
AP 2
TSEL @grabFoodRight @noFood
LDC 1          ; there is, so go right ; @grabFoodRight
RTN
LD 0 0         ; no food, no direction change ; @noFood
RTN

LD 0 0         ; the world ; @isThereFood
LD 0 1         ; position to check
CDR            ; which row
DUM 2
LDF @nth
RAP 2
LD 0 1
CAR            ; which cell in row
DUM 2
LDF @nth
RAP 2

LDC 2          ; food = 2 | 3 | 4
LDC 4
LDF @isInRange
AP 3
RTN

LD 0 0         ; @isInRange
LD 0 1
CGTE
LD 0 2
LD 0 0
CGTE
MUL
RTN

LD 0 0         ; @addVectors
CAR
LD 0 1
CAR
ADD
LD 0 0
CDR
LD 0 1
CDR
ADD
CONS
RTN

LD 0 0         ; list ; @nth
LD 0 1         ; position
TSEL @tail @head
CAR            ; just get head ; @head
RTN
CDR            ; take tail ; @tail
LD 0 1         ; subtract one
LDC 1
SUB
LDF @nth          ; recursive call
TAP 2


LD 0 0         ; @comparePairs
CAR
LD 0 1
CAR
CEQ
LD 0 0
CDR
LD 0 1
CDR
CEQ
MUL            ; MUL = AND
RTN

LD 0 0         ; @modulo
LD 0 1
LD 0 0
LD 0 1
DIV
MUL
SUB
RTN