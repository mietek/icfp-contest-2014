LDC 0          ; initial state
LDF @stepFunction
CONS
RTN
; ------------------------------------------------------------------------------
; @stepFunction
; arguments: AI State, World State
; returns: AI State, direction of next move
; ------------------------------------------------------------------------------
LDC 0          ; @stepFunction
LDC 3          ; start checking moves starting with 3
LDC -1          ; placeholder for best score
LDC -1          ; placeholder for current score
LDC -1         ; placeholder for best move
LD 0 1         ; the world state
LDF @evaluateMoves
AP 5           ; get best move
CONS           ; returning (state, direction)
RTN

; ------------------------------------------------------------------------------
; @evaluateMoves
; arguments: direction, *best score, *current score, *best move, world
; returns: direction
; ------------------------------------------------------------------------------
LD 0 0         ; current direction to check ; @evaluateMoves
LDC 3         ; iterations count for evaluateMove
LDC 0          ; accumulator for cumulative score of iterations
LD 0 4         ; pass the current world state
DUM 4
LDF @evaluateMove
RAP 4
ST 0 2         ; store current score for later
LD 0 2         ; load again to compare with
LD 0 1         ; the best one so far
CGT
SEL @gotBetterScore @gotWorseScore
LD 0 0
TSEL @checkNextMove @returnBestMove

LD 0 0         ; load current direction ; @checkNextMove
LDC 1
SUB            ; and subtract 1 to have the next one
LD 0 1         ; best score so far
LDC 0          ; current score
LD 0 3         ; best move
LD 0 4         ; world
LDF @evaluateMoves
TAP 5          ; recursive call

LD 0 3         ; @returnBestMove
RTN

LD 0 2         ; @gotBetterScore
ST 0 1
LD 0 0
ST 0 3
JOIN           ; @gotWorseScore

; ------------------------------------------------------------------------------
; @evaluateMove
; arguments: direction, iterations count, *cumulative score, world
; returns: cumulative score
; ------------------------------------------------------------------------------

LD 0 1         ; iterations count ; @evaluateMove
TSEL @doAnotherIteration @returnCumulativeScore
LD 0 2         ; @returnCumulativeScore
RTN

LD 0 2         ; score so far ; @doAnotherIteration

LD 0 0         ; direction
LD 0 3         ; world
LDC 2          ; how many steps in single simulation
LDF @runSimulation
AP 3           ; get the resulting world

LDF @evaluateWorld
AP 1           ; get the new score

ADD            ; add it to the previous one
ST 0 2         ; and store for later
LD 0 0         ; preparing arguments for recursive call
LD 0 1
LDC -1         ; decrease the iterations count
ADD
LD 0 2
LD 0 3
LDF @evaluateMove
TAP 4

; ------------------------------------------------------------------------------
; @runSimulation
; arguments: direction, world, iteration
; returns: world
; ------------------------------------------------------------------------------
LD 0 0         ; @runSimulation
LD 0 1
LDC 0
LDC 0
LDC 0
LDC 0
LDF @simulateMove
AP 6           ; returns new world state
ST 0 1         ; store it for later
LD 0 2
TSEL @doAnotherSimulationIteration @returnFinalWorld
LD 0 1         ; @returnFinalWorld
RTN
LD 0 0         ; @doAnotherSimulationIteration
LDF @generateNextRandomDirection
AP 1
LD 0 1         ; current world state
LD 0 2         ; iterations count
LDC -1         ; decreased by 1
ADD
LDF @runSimulation
TAP 3

; ------------------------------------------------------------------------------
; @generateNextRandomDirection
; arguments: direction
; returns: new direction
; ------------------------------------------------------------------------------
LD 0 0         ; @generateNextRandomDirection
RTN            ; to be implemented

; ------------------------------------------------------------------------------
; @simulateMove
; arguments: direction, world, *map, *player, *ghosts, *fruit
; returns: new world
; ------------------------------------------------------------------------------
; data structures unpacking
; --
LD 0 1         ; @simulateMove
CAR            ; extract map
ST 0 2         ; and store it in the frame

LD 0 1         ; extract player
CDR
CAR
ST 0 3         ; and store it in the frame

LD 0 1         ; extract ghosts
CDR
CDR
CAR
ST 0 4

LD 0 1         ; extract fruit
CDR
CDR
CDR
ST 0 5
; --
; actual simulation
; --
LD 0 0         ; movePlayer(direction, map, player) -> player
LD 0 2
LD 0 3
LDC -1
LDF @movePlayer
AP 4
ST 0 3         ; store the new player

LD 0 2         ; checkCollectibles(map, player, fruit, *cell)
LD 0 3
LD 0 5
LDC 0
LDF @checkCollectibles
AP 4
ST 0 5         ; store the new fruit
ST 0 3         ; store the new player
ST 0 2         ; store the new map

; --
; packing new data structures
; --
LD 0 2
LD 0 3
LD 0 4
LD 0 5
CONS
CONS
CONS
RTN

; ------------------------------------------------------------------------------
; @movePlayer
; arguments: direction, map, player, *temp
; returns: new player
; ------------------------------------------------------------------------------
LD 0 2         ; @movePlayer
CAR            ; player -> vitality

; --
; actual function
; --
LD 0 0
LDF @directionToVector
AP 1           ; vector to move the player

LD 0 2         ; the player himself
CDR
CAR            ; and his location

LDF @addVectors
AP 2           ; new position of player
ST 0 3

LD 0 1
LD 0 3
LDF @getMapCell
AP 2
LDC 1          ; 1 = wall
CEQ
SEL @unableToMove @ableToMove

LD 0 0         ; new direction of player

LD 0 2
CDR            ; player -> (lives, score)
CDR
CDR

CONS           ; pack the new player
CONS
CONS

RTN

LD 0 2         ; @unableToMove
CDR
CAR            ; keep old location
JOIN

LD 0 3         ; @ableToMove
JOIN           ; using the new one
; ------------------------------------------------------------------------------
; @checkCollectibles
; arguments: map, player, fruit, *cell content
; returns: new map, new player, new fruit
; ------------------------------------------------------------------------------
LD 0 0         ; the map ; @checkCollectibles

LD 0 1         ; player -> location
CDR
CAR

LDF @getMapCell
AP 2
ST 0 3         ; save for future access

LD 0 3
LDC 2          ; is it pill?
CEQ
SEL @ccPill @ccNoPill

LD 0 3
LDC 3          ; is it power pill?
CEQ
SEL @ccPowerPill @ccNoPowerpill

LD 0 3
LDC 4          ; could it be the fruit?
CEQ
SEL @ccFruit @ccNoFruit

; return all the new data
LD 0 0
LD 0 1
LD 0 2
RTN

LD 0 1         ; player ; @ccPill
LDC 10         ; 10 points for eating pill
LDF @increasePlayerScore
AP 2
ST 0 1         ; save the updated player
JOIN           ; @ccNoPill

LD 0 1         ; player ; @ccPowerPill
LDC 50         ; t0 points for eating power pill
LDF @increasePlayerScore
AP 2
ST 0 1         ; save the updated player
JOIN           ; @ccNoPowerpill

LD 0 1         ; player ; @ccFruit
LDC 10         ; 700 points for eating fruit
LDF @increasePlayerScore
AP 2
ST 0 1         ; save the updated player
JOIN           ; @ccNoFruit

; ------------------------------------------------------------------------------
; @evaluateWorld
; arguments: world
; returns: score
; ------------------------------------------------------------------------------
LD 0 0         ; @evaluateWorld
CDR            ; player
CAR
CDR            ; player -> score
CDR
CDR
CDR
LDC 1          ; p1 - multiplier for score
MUL

LD 0 0
CDR            ; player
CAR
CDR            ; player -> lives
CDR
CDR
CAR
LDC 10000      ; p2 - multiplier for lives
MUL

LD 0 0
CDR            ; player
CAR
CAR            ; player -> vitality
LDC 0
CGT            ; we only want to know if fright mode is on
LDC 1000       ; p4 - multiplier for fright mode
MUL

ADD
ADD
RTN
; ------------------------------------------------------------------------------
; @isInRange
; arguments: x,min,max
; returns: 0/1 (if min ≤ x ≤ max)
; ------------------------------------------------------------------------------
LD 0 0         ; @isInRange
LD 0 1
CGTE
LD 0 2
LD 0 0
CGTE
MUL            ; MUL == logical AND
RTN
; ------------------------------------------------------------------------------
; @addVectors
; arguments: v1, v2
; returns: v3 = v1 + v2
; ------------------------------------------------------------------------------
LD 0 0         ; @addVectors
CAR
LD 0 1
CAR
ADD
LD 0 0
CDR
LD 0 1
CDR
ADD
CONS
RTN
; ------------------------------------------------------------------------------
; @compareVectors
; arguments: v1, v2
; returns: 0/1 (v1 == v2)
; ------------------------------------------------------------------------------
LD 0 0         ; @compareVectors
CAR
LD 0 1
CAR
CEQ
LD 0 0
CDR
LD 0 1
CDR
CEQ
MUL            ; MUL == logical AND
RTN
; ------------------------------------------------------------------------------
; @directionToVector
; arguments: direction
; returns: vector
; ------------------------------------------------------------------------------
LD 0 0         ; @directionToVector
LDC 0
CEQ
TSEL @dtvUp @dtvNotUp
LDC 0          ; @dtvUp
LDC -1
CONS
RTN

LD 0 0         ; @dtvNotUp
LDC 1
CEQ
TSEL @dtvRight @dtvNotRight
LDC 1          ; @dtvRight
LDC 0
CONS
RTN

LD 0 0         ; @dtvNotRight
LDC 2
CEQ
TSEL @dtvDown @dtvLeft
LDC 0          ; @dtvDown
LDC 1
CONS
RTN

LDC -1         ; @dtvLeft
LDC 0
CONS
RTN
; ------------------------------------------------------------------------------
; @modulo
; arguments: a, b
; returns: c = a mod b
; ------------------------------------------------------------------------------
LD 0 0         ; @modulo
LD 0 1
LD 0 0
LD 0 1
DIV
MUL
SUB
RTN
; ------------------------------------------------------------------------------
; @getMapCell
; arguments: map, coordinates
; returns: contents of the given cell
; ------------------------------------------------------------------------------
LD 0 0         ; map ; @getMapCell
LD 0 1         ; row
CDR
LDF @nth
AP 2

LD 0 1         ; column
CAR
LDF @nth
AP 2
RTN
; ------------------------------------------------------------------------------
; @nth
; arguments: list, position
; returns: nth element from list
; ------------------------------------------------------------------------------
LD 0 0         ; @nth
LD 0 1
LDC 0
CGT
TSEL @nthTail @nthHead
CAR            ; just return head ; @nthHead
RTN
CDR            ; take tail ; @nthTail
LD 0 1         ; subtract one from position
LDC 1
SUB
LDF @nth
TAP 2          ; and call recursively
; ------------------------------------------------------------------------------
; @updateNth
; arguments: list, position, new value
; returns: updated list
; ------------------------------------------------------------------------------
LD 0 1         ; @updateNth
LDC 0          ; is this the position we're looking for?
CGT
TSEL @unTail @unHead
LD 0 2         ; new value ; @unHead
LD 0 0         ; rest of the values
CDR
CONS
RTN

LD 0 0         ; preserve the head ; @unTail
CAR

LD 0 0         ; recursively compute the rest
CDR
LD 0 1
LDC 1
SUB
LD 0 2
LDF @updateNth
AP 3
CONS           ; append the head to the rest
RTN
; ------------------------------------------------------------------------------
; @addToNth
; arguments: list, position, increment
; returns: updated list
; ------------------------------------------------------------------------------
LD 0 0         ; list ; @addToNth
LD 0 1         ; position

LD 0 0         ; new value
LD 0 1
LDF @nth
AP 2

LD 0 2
ADD

LDF @updateNth
AP 3
RTN
; ------------------------------------------------------------------------------
; @increasePlayerScore
; arguments: player, points
; returns: updated player
; ------------------------------------------------------------------------------
LD 0 0         ; @increasePlayerScore
CAR

LD 0 0
CDR
CAR

LD 0 0
CDR
CDR
CAR

LD 0 0
CDR
CDR
CDR
CAR

LD 0 0
CDR
CDR
CDR
CDR
LD 0 1
ADD

CONS
CONS
CONS
CONS
RTN
; ------------------------------------------------------------------------------
