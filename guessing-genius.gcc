LDC 0          ; initial state
LDF 4
CONS
RTN
LDC 0          ; @stepFunction
LDC 3          ; start checking moves starting with 3
LDC 0          ; placeholder for best score
LDC 0          ; placeholder for current score
LDC 0          ; placholder for best move
LD 0 1         ; the world state
DUM 5
LDF 15
RAP 5          ; get best move
CONS           ; returning (state, direction)
RTN
LD 0 0         ; current direction to check ; @evaluateMoves
LDC 5          ; iterations count for evaluateMove
LDC 0          ; accumulator for cumulative score of iterations
LD 0 4         ; pass the current world state
DUM 4
LDF 45
RAP 4
ST 0 2         ; store current score for later
LD 0 2         ; load again to compare with
LD 0 1         ; the best one so far
CGT
SEL 40 44
LD 0 0
TSEL 29 38
LD 0 0         ; load current direction ; @checkNextMove
LDC -1
ADD            ; and subtract 1 to have the next one
LD 0 1         ; best score so far
LD 0 2         ; current score
LD 0 3         ; best move
LD 0 4         ; world
LDF 15
TAP 5          ; recursive call
LD 0 3         ; @returnBestMove
RTN
LD 0 2         ; @gotBetterScore
ST 0 1
LD 0 0
ST 0 3
JOIN           ; @gotWorseScore
LD 0 1         ; iterations count ; @evaluateMove
TSEL 49 47
LD 0 2         ; @returnCumulativeScore
RTN
LD 0 2         ; score so far ; @doAnotherIteration
LD 0 0         ; direction
LD 0 3         ; world
LDC 5          ; iterations count for single simulation
LDF 76
AP 3           ; get the resulting world
LDF 141
AP 1           ; get the new score
ADD            ; add it to the previous one
ST 0 2         ; and store for later
LD 0 0         ; preparing arguments for recursive call
LD 0 1
LDC -1         ; decrease the iterations count
ADD
LD 0 2
LD 0 3
LDF 45
TAP 4
LD 0 0         ; @runSimulation
LD 0 1
LDC 0
LDC 0
LDC 0
LDC 0
LDF 91
AP 6           ; returns new world state
ST 0 1         ; store it for later
LD 0 2         ; @runSimulation
TSEL 80 78
LD 0 1         ; @returnFinalWorld
RTN
LD 0 0         ; @doAnotherSimulationIteration
LDF 89
AP 1
LD 0 1         ; current world state
LD 0 2         ; iterations count
LDC -1         ; decreased by 1
ADD
LDF 76
TAP 3
LD 0 0         ; @generateNextRandomDirection
RTN            ; to be implemented
LD 0 1         ; @simulateMove
CAR            ; extract map
ST 0 2         ; and store it in the frame
LD 0 1         ; extract player
CDR
CAR
ST 0 3         ; and store it in the frame
LD 0 1         ; extract ghosts
CDR
CDR
CAR
ST 0 4
LD 0 1         ; extract fruit
CDR
CDR
CDR
ST 0 5
LD 0 0         ; movePlayer(direction, map, player) -> player
LD 0 2
LD 0 3
LDF 122
AP 3
ST 0 3         ; store the new player
LD 0 2         ; pack the new world again
LD 0 3
LD 0 4
LD 0 5
CONS
CONS
CONS
RTN
LD 0 2         ; @movePlayer
CAR            ; player -> vitality
LD 0 0
LDF 202
AP 1           ; vector to move the player
LD 0 2         ; the player himself
CDR
CAR            ; and his location
LDF 178
AP 2           ; new position of player
LD 0 0         ; new direction of player
LD 0 2
CDR            ; player -> (lives, score)
CDR
CDR
CONS           ; pack the new player
CONS
CONS
RTN
LD 0 0         ; @evaluateWorld
CDR            ; player
CAR
CDR            ; player -> score
CDR
CDR
CDR
LDC 1          ; p1 - multiplier for score
MUL
LD 0 0
CDR            ; player
CAR
CDR            ; player -> lives
CDR
CDR
CAR
LDC 10000      ; p2 - multiplier for lives
MUL
LD 0 0
CDR            ; player
CAR
CAR            ; player -> vitality
LDC 0
CGT            ; we only want to know if fright mode is on
LDC 1000       ; p4 - multiplier for fright mode
MUL
ADD
ADD
RTN
LD 0 0         ; @isInRange
LD 0 1
CGTE
LD 0 2
LD 0 0
CGTE
MUL            ; MUL == logical AND
RTN
LD 0 0         ; @addVectors
CAR
LD 0 1
CAR
ADD
LD 0 0
CDR
LD 0 1
CDR
ADD
CONS
RTN
LD 0 0         ; @compareVectors
CAR
LD 0 1
CAR
CEQ
LD 0 0
CDR
LD 0 1
CDR
CEQ
MUL            ; MUL == logical AND
RTN
LD 0 0         ; @directionToVector
LDC 0
CEQ
TSEL 206 210
LDC 0          ; @dtvUp
LDC -1
CONS
RTN
LD 0 0         ; @dtvNotUp
LDC 1
CEQ
TSEL 214 218
LDC 1          ; @dtvRight
LDC 0
CONS
RTN
LD 0 0         ; @dtvNotRight
LDC 2
CEQ
TSEL 222 226
LDC 0          ; @dtvDown
LDC 1
CONS
RTN
LDC -1         ; @dtvLeft
LDC 0
CONS
RTN
LD 0 0         ; @modulo
LD 0 1
LD 0 0
LD 0 1
DIV
MUL
SUB
RTN
LD 0 0         ; @nth
LD 0 1
LDC 0
CGT
TSEL 245 243
CAR            ; just return head ; @nthHead
RTN
CDR            ; take tail ; @nthTail
LD 0 1         ; subtract one from position
LDC 1
SUB
LDF 238
TAP 2          ; and call recursively
