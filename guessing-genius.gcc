LDC 314          ; initial state, seed for PRNG
LDF 4
CONS
RTN
LD 0 0         ; @stepFunction
LDF 19
AP 1
ST 0 0
LD 0 0
LDC 3          ; start checking moves starting with 3
LDC -1         ; placeholder for best score
LDC -1         ; placeholder for current score
LDC -1         ; placeholder for best move
LD 0 1         ; the world state
LD 0 0
LDF 28
AP 6           ; get best move
CONS           ; returning (state, direction)
RTN
LD 0 0         ; @generateNewRandom
LDC 9821
MUL
LDC 6925
ADD
LDC 65535
LDF 463
AP 2
RTN
LD 0 0         ; current direction to check ; @evaluateMoves
LDC 20         ; iterations count for evaluateMove
LDC 0          ; accumulator for cumulative score of iterations
LD 0 4         ; pass the current world state
LD 0 5         ; and random seed
DUM 5
LDF 62
RAP 5
ST 0 2         ; store current score for later
LD 0 2         ; load again to compare with
LD 0 1         ; the best one so far
CGT
SEL 57 61
LD 0 0
TSEL 43 55
LD 0 0         ; load current direction ; @checkNextMove
LDC 1
SUB            ; and subtract 1 to have the next one
LD 0 1         ; best score so far
LDC 0          ; current score
LD 0 3         ; best move
LD 0 4         ; world
LD 0 5         ; random seed
LDF 19
AP 1
LDF 28
TAP 6          ; recursive call
LD 0 3         ; @returnBestMove
RTN
LD 0 2         ; @gotBetterScore
ST 0 1
LD 0 0
ST 0 3
JOIN           ; @gotWorseScore
LD 0 1         ; iterations count ; @evaluateMove
TSEL 66 64
LD 0 2         ; @returnCumulativeScore
RTN
LD 0 2         ; score so far ; @doAnotherIteration
LD 0 0         ; direction
LD 0 3         ; world
LDC 7          ; how many steps in single simulation
LD 0 4         ; randomness
LDF 91
AP 4           ; get the resulting world
LD 0 4         ; add some randomness to evaluation as well
LDF 369
AP 2           ; get the new score
ADD            ; add it to the previous one
ST 0 2         ; and store for later
LD 0 0         ; preparing arguments for recursive call
LD 0 1
LDC -1         ; decrease the iterations count
ADD
LD 0 2
LD 0 3
LD 0 4
LDF 19
AP 1
LDC 1
ADD
LDF 62
TAP 5
LD 0 0         ; @runSimulation
LD 0 1
LDC 0
LDC 0
LDC 0
LDC 0
LD 0 3
LDF 141
AP 7           ; returns new world state
ST 0 1         ; store it for later
LD 0 2
TSEL 105 103
LD 0 1         ; @returnFinalWorld
RTN
LD 0 0         ; @doAnotherSimulationIteration
LD 0 3
LDF 118
AP 2
LD 0 1         ; current world state
LD 0 2         ; iterations count
LDC -1         ; decreased by 1
ADD
LD 0 3
LDF 19
AP 1
LDF 91
TAP 4
LD 0 1         ; @generateNextRandomDirection
LDC 3          ; 33% chance to change direction
LDF 463
AP 2
TSEL 123 125
LD 0 0         ; @leaveSameDirection
RTN
LD 0 0         ; @randomlyRotate
LD 0 1
LDC 2
LDF 463
AP 2
SEL 135 138
LDC 4
LDF 463
AP 2
RTN
LDC 1          ; @rotateLeft
ADD
JOIN
LDC -1         ; @rotateRight
ADD
JOIN
LD 0 1         ; @simulateMove
CAR            ; extract map
ST 0 2         ; and store it in the frame
LD 0 1         ; extract player
CDR
CAR
ST 0 3         ; and store it in the frame
LD 0 1         ; extract ghosts
CDR
CDR
CAR
ST 0 4
LD 0 1         ; extract fruit
CDR
CDR
CDR
ST 0 5
LD 0 0         ; movePlayer(direction, map, player) -> player
LD 0 2
LD 0 3
LDC -1
LDF 193
AP 4
ST 0 3         ; store the new player
LD 0 2         ; moveGhosts(map, ghosts) -> ghosts
LD 0 4
LD 0 6
LDF 271
AP 3
ST 0 4         ; store the new ghosts
LD 0 3         ; checkGhostCollisions(player, ghosts)
LD 0 4
LDF 293
AP 2
ST 0 3         ; store the new player
LD 0 2         ; checkCollectibles(map, player, fruit, *cell)
LD 0 3
LD 0 5
LDC 0
LDF 325
AP 4
ST 0 5         ; store the new fruit
ST 0 3         ; store the new player
ST 0 2         ; store the new map
LD 0 2
LD 0 3
LD 0 4
LD 0 5
CONS
CONS
CONS
RTN
LD 0 2         ; @movePlayer
CAR            ; player -> vitality
LD 0 0
LDF 435
AP 1           ; vector to move the player
LD 0 2         ; the player himself
CDR
CAR            ; and his location
LDF 411
AP 2           ; new position of player
ST 0 3
LD 0 1
LD 0 3
LDF 471
AP 2
LDC 0          ; 0 = wall
CEQ
SEL 220 224
LD 0 0         ; new direction of player
LD 0 2
CDR            ; player -> (lives, score)
CDR
CDR
CONS           ; pack the new player
CONS
CONS
RTN
LD 0 2         ; @unableToMove
CDR
CAR            ; keep old location
JOIN
LD 0 3         ; @ableToMove
JOIN           ; using the new one
LD 0 1         ; @moveOneGhost
CDR            ; take his direction
CDR
LD 0 3         ; randomly change it
LDC 3          ; 1/3 chance to do it
LDF 463
AP 2
SEL 270 260
LDF 435
AP 1           ; vector to move the ghost
LD 0 1         ; current ghost position
CDR
CAR
LDF 411
AP 2           ; new position of ghost
ST 0 2
LD 0 0
LD 0 2
LDF 471
AP 2
LDC 0
CEQ
TSEL 249 251
LD 0 1         ; @ghostUnableToMove
RTN
LD 0 1         ; @ghostAbleToMove
CAR
LD 0 2         ; substitute the new location
LD 0 1         ; preserve direction
CDR
CDR
CONS
CONS
RTN
LD 0 3         ; @changingGhostDirection
LDC 3
LDF 463
AP 2
LDC 1
SUB
ADD
LDC 4
LDF 463
AP 2
JOIN           ; @notChangingGhostDirection
LD 0 1         ; @moveGhosts
ATOM           ; check for the end of list
TSEL 274 276
LDC 0          ; @noMoreMovingGhosts
RTN
LD 0 0         ; @moveNextGhost
LD 0 1
CAR
LDC -1
LD 0 2
LDF 226
AP 4
LD 0 0         ; recursively move the rest
LD 0 1
CDR
LD 0 2
LDF 19
AP 1
LDF 271
AP 3
CONS           ; and merge results
RTN
LD 0 1         ; @checkGhostCollisions
ATOM           ; check for end of the list
TSEL 296 298
LD 0 0         ; @notDead
RTN
LD 0 1         ; @checkGhostDeath
CAR            ; ghost location
CDR
CAR
LD 0 0         ; player location
CDR
CAR
LDF 423
AP 2
TSEL 308 320
LD 0 0         ; @collision
CAR
TSEL 315 311
LD 0 0         ; @dead
LDF 526
AP 1
RTN
LD 0 0         ; @eatGhost
LDC 200
LDF 552
AP 2
RTN
LD 0 0         ; @keepLookingForDeath
LD 0 1
CDR
LDF 293
TAP 2
LD 0 0         ; the map ; @checkCollectibles
LD 0 1         ; player -> location
CDR
CAR
LDF 471
AP 2
ST 0 3         ; save for future access
LD 0 3
LDC 2          ; is it pill?
CEQ
SEL 348 353
LD 0 3
LDC 3          ; is it power pill?
CEQ
SEL 354 359
LD 0 3
LDC 4          ; could it be the fruit?
CEQ
SEL 360 367
LD 0 0
LD 0 1
LD 0 2
RTN
LD 0 1         ; player ; @ccPill
LDC 10         ; 10 points for eating pill
LDF 552
AP 2
ST 0 1         ; save the updated player
JOIN           ; @ccNoPill
LD 0 1         ; player ; @ccPowerPill
LDC 50         ; t0 points for eating power pill
LDF 552
AP 2
ST 0 1         ; save the updated player
JOIN           ; @ccNoPowerpill
LD 0 2         ; @ccFruit
TSEL 362 368
LD 0 1         ; player ; @ccFruitActive
LDC 700         ; 700 points for eating fruit
LDF 552
AP 2
ST 0 1         ; save the updated player
JOIN           ; @ccNoFruit
JOIN           ; @ccFruitInactive
LD 0 0         ; @evaluateWorld
CDR            ; player
CAR
CDR            ; player -> score
CDR
CDR
CDR
LDC 1          ; p1 - multiplier for score
MUL
LD 0 0
CDR            ; player
CAR
CDR            ; player -> lives
CDR
CDR
CAR
LDC 10000      ; p2 - multiplier for lives
MUL
LD 0 0
CDR            ; player
CAR
CAR            ; player -> vitality
LDC 0
CGT            ; we only want to know if fright mode is on
LDC 1000       ; p4 - multiplier for fright mode
MUL
ADD
ADD
LD 0 1         ; add some noise
LDC 10         ; max. 9 points
LDF 463
AP 2
ADD
RTN
LD 0 0         ; @isInRange
LD 0 1
CGTE
LD 0 2
LD 0 0
CGTE
MUL            ; MUL == logical AND
RTN
LD 0 0         ; @addVectors
CAR
LD 0 1
CAR
ADD
LD 0 0
CDR
LD 0 1
CDR
ADD
CONS
RTN
LD 0 0         ; @compareVectors
CAR
LD 0 1
CAR
CEQ
LD 0 0
CDR
LD 0 1
CDR
CEQ
MUL            ; MUL == logical AND
RTN
LD 0 0         ; @directionToVector
LDC 0
CEQ
TSEL 439 443
LDC 0          ; @dtvUp
LDC -1
CONS
RTN
LD 0 0         ; @dtvNotUp
LDC 1
CEQ
TSEL 447 451
LDC 1          ; @dtvRight
LDC 0
CONS
RTN
LD 0 0         ; @dtvNotRight
LDC 2
CEQ
TSEL 455 459
LDC 0          ; @dtvDown
LDC 1
CONS
RTN
LDC -1         ; @dtvLeft
LDC 0
CONS
RTN
LD 0 0         ; @modulo
LD 0 1
LD 0 0
LD 0 1
DIV
MUL
SUB
RTN
LD 0 0         ; map ; @getMapCell
LD 0 1         ; row
CDR
LDF 481
AP 2
LD 0 1         ; column
CAR
LDF 481
AP 2
RTN
LD 0 0         ; @nth
LD 0 1
LDC 0
CGT
TSEL 488 486
CAR            ; just return head ; @nthHead
RTN
CDR            ; take tail ; @nthTail
LD 0 1         ; subtract one from position
LDC 1
SUB
LDF 481
TAP 2          ; and call recursively
LD 0 1         ; @updateNth
LDC 0          ; is this the position we're looking for?
CGT
TSEL 503 498
LD 0 2         ; new value ; @unHead
LD 0 0         ; rest of the values
CDR
CONS
RTN
LD 0 0         ; preserve the head ; @unTail
CAR
LD 0 0         ; recursively compute the rest
CDR
LD 0 1
LDC 1
SUB
LD 0 2
LDF 494
AP 3
CONS           ; append the head to the rest
RTN
LD 0 0         ; list ; @addToNth
LD 0 1         ; position
LD 0 0         ; new value
LD 0 1
LDF 481
AP 2
LD 0 2
ADD
LDF 494
AP 3
RTN
LD 0 0         ; @decreaseLives
CAR
LD 0 0
CDR
CAR
LD 0 0
CDR
CDR
CAR
LD 0 0
CDR
CDR
CDR
CAR
LDC 1
SUB
LD 0 0
CDR
CDR
CDR
CDR
CONS
CONS
CONS
CONS
RTN
LD 0 0         ; @increasePlayerScore
CAR
LD 0 0
CDR
CAR
LD 0 0
CDR
CDR
CAR
LD 0 0
CDR
CDR
CDR
CAR
LD 0 0
CDR
CDR
CDR
CDR
LD 0 1
ADD
CONS
CONS
CONS
CONS
RTN
